### 非同步操作


---
閱讀列表:
 - [Callback](#^2b0bfb)
 - [XMLHttpRequest](#^a7c13f)
 - [Promise](#^aa0411)
 - [Async/Await](#^15ed02)
 - [Fetch](#^a3383b)
	 \* [XMLHttpRequest VS. Fetch](#^ddf68b)
 - [AJAX](#^5516fd)
---


#### 🔵 Callback: 將函式作為參數傳入其他函式 

^2b0bfb

---
將函式A作為參數傳入B函式 於B中呼叫A 使A在指定時機執行
因將函式控制權(呼叫權)交出 故難以掌握其他呼叫細節 且難處理多層依賴

```js=
function process(data,next){
	console.log(`${data}處理中`);
	next(data);
}
function end(data){
	console.log(`${data}處理完畢!`);
}

process("資料001",end);
```


#### 🟠 XMLHttpRequest物件: 網頁部分更新

^a7c13f
---
 一browser內建物件 用於 **在背景** 與server交換資料(發送HTTP請求與處理回應) 使網頁不需整頁刷新也能更新內容

XHR物件狀態變化:
```txt=
0 unsent: 已建立XHR物件 尚未初始化(尚未呼叫.open())

1 opened: 已設定請求參數 尚未送出(尚未呼叫.send())

2 headers_received: 已送出請求且收到狀態碼與回應headers 尚未收到回應body

3 loading: 正在接收回應body的資料

4 done: 請求操作完成
```
\*可透過.readyState屬性查看 狀態變化會觸發readystatechange事件

建立與初始化( 0 --> 1 ):
```js=
const xhr= new XMLHttpRequest();
xhr.open(請求方法, URL, 是否同步); //設定請求參數
```
設定回應處理:
```js=
xhr.addEventListener("load",function(){...}); //請求完成且伺服器回應觸發load事件(操作不一定成功)
xhr.addEventListener("error",function(){...}); //請求失敗觸發
```
發送請求( 1 --> 2):
```js=
xhr.send();
```


>▫️XHR物件的屬性與方法
>	- .readyState: 請求狀態
>	- .timeout: 設定請求等待時間
>	- .status: 伺服器回應的HTTP狀態碼
>	- .responseText: 伺服器回應資料 為文字形式
>	- .open( )
>	- .send( )
>	- .abort( ): 終止發送的請求
>	- setRequestHeader( ): 設定請求標頭 僅可在.open()後、.send()前呼叫
>▫️觸發事件
>	- load
>	- error
>	- abort: 請求被取消
>	- progress: xhr正在下載(接收)回應資料
>	- timeout: 請求逾時

```js=
const xhr= new XMLHttpRequest();
xhr.open('GET','https://jsonplaceholder.typicode.com/todos/1',true);
xhr.timeout= 2000; //設定請求等待2000毫秒

xhr.addEventListener("error",()=>{
	console.log('請求發送失敗');
});
xhr.addEventListener("load",()=>{
	if(xhr.status==200){
		console.log('操作執行成功!');
		console.log(`以下為執行結果: ${xhr.responseText}`);
	}else{
		console.log('操作執行失敗');
	}
});
xhr.addEventListener("timeout",()=>{
	console.log('請求逾時');
});

xhr.send();
```
\*現通常使用fetch( )



#### 🔵 Promise:  JS中用於處理非同步操作的物件

^aa0411

---
表示一 **尚未完成但晚點會得到回應** 的操作, 在callback的基礎上加強

> ▫️狀態機制: Promise分為三種狀態 分別為pending(尚未操作: 為Promise的初始狀態), fulfilled(操作完成), rejected(操作失敗), 一旦Promise物件 **狀態改變就會固定**(不可逆操作)
>
>▫️錯誤傳遞: .catch()會捕捉前方的所有錯誤
>
>▫️鏈式結構: 多層依賴關係使用.then()串接

使用:
1. 建立
```js=
const myPromise= new Promise((resolve,reject)=>{
	if(成功條件){
		resolve(response)
	}else{
		reject(reason)
	}
})
```
* resolve(response): 將promise的狀態改為fulfilled 並把response傳入.then()
* reject(reason): 將promise的狀態改為rejected 並把reason傳入.catch()
* Promise不會自動rejected 須在函式內手動reject


2. 監聽
```js=
myPromise.then(...)
.then(...)
...
.catch(...)
```
- .then(): 會接收前一個.then()的回傳值作為參數 若回傳值為Promise物件 JS會等待其執行完畢
- .catch(): 捕捉前方所有錯誤 若前方有一.then()報錯會直接跳到.catch()

常用方法:
- Promise.all(Promise物件陣列): 等待所有Promise完成並回傳一結果陣列 若其中有一Promise報錯會直接跳至.catch()

- Promise.allSettled: 等待所有Promise完成並回傳一結果物件陣列 即使其中一Promise報錯也不會停止

- Promise.race(Promise物件陣列): 回傳最快完成的Promise物件(可能為fulfilled或rejected)

- Promise.any(Promise物件陣列): 回傳最快成功(fulfilled)的Promise物件 會忽略失敗直到所有Promise都失敗才報錯



#### 🔵 Async/Await: Promise的語法糖

^15ed02

---
>▫️**async**: 置於函式開頭 表示此函式最後會回傳一Promise物件 (若非Promise會被包裝)
>
>▫️**await**: 只能寫在async函式中 置於statement前 用於等待Promise執行完畢 程式遇到await關鍵字會暫停整個async函式直到Promise執行完畢(狀態改變) 但主函式會繼續執行

\*async/await寫法中除錯會使用try{  }catch( ){  }```

```js=
async function processor(data,time){
	try{
		if(time<0){
			throw new Error('時間不可為負數!');
		}
		await new Promise((resolve)=>{
			setTimeout(()=>{
				console.log(`${data}處理中...`);
				resolve(); //await會等待Promise狀態轉變
			},time);	
		});	
		console.log(`${data}處理完畢!`);
	}catch(e){
		console.log(`something wrong: ${e.message}`);
	}
}
processor('資料1',2000);
processor('資料2',-1); //something wrong: 時間不可為負數!
```
\*若async函式沒有明確return會回傳undefined 故以上程式會回傳undefined


#### 🟠 Fetch: 基於Promise發出HTTP請求

^a3383b

---

一基於Promise物件的API 用於向指定網址發送HTTP請求


語法:
```js=
fetch(URL,請求參數);
```
\*函式會回傳一Promise物件(代表正在等待HTTP回應) 當請求被回覆時 會將其狀態改為fulfilled(代表fetch操作成功) 並回傳一Response物件, 僅請求無法送達(網路層錯誤)時會rejected(**故即使操作執行失敗也為fulfilled**)

常見請求參數:
- method (方法):
	GET, POST, PUT, DELETE
- headers (標頭):
	Content-Type(資料格式), Accept(回應格式), ...
- body (主體內容)

```js=
fetch('https://jsonplaceholder.typicode.com/todos/1'{
	method: 'POST', //使用的HTTP方法
	headers: {
		'Content-type': 'application/json', //請求所含資料類型
	}
	body: JSON.stringify({
		key: 'value', //請求所傳遞之資料
	})
});
```

>▫️Response物件的屬性與方法
>	-  .ok: 回傳Response操作是否成功(HTTP狀態碼於200-299)
>	-  .status: 回傳Response的HTTP狀態碼
>	-  .json( )/ .text( )/ .formData( )/ ... : 將Response解析為指定資料格式回傳 (回傳為一Promise) 

Promise寫法:
```js=
fetch('https://jsonplaceholder.typicode.com/todos/1')
.then((response)=>{
	if(response.ok){
		return response;
	}else{
		throw new Error('操作執行失敗');
	}
}).then((result)=>{
	console.log('操作執行成功!');
	return result.json(); //.json()會將response解析為JS物件
}).then((data)=>{
	console.log('以下為執行結果:' ,data);
}).catch((reason)=>{
	console.log(`HTTP請求失敗: ${reason}`);
});
```

Async/Await寫法:
```js=
async function httpRequest(URL){
	try{
		const request= await fetch(URL);
		if(request.ok){
			console.log('操作執行成功!');
			const data= await request.json();
			console.log('以下為執行結果:' ,data);
		}else{
			throw new Error('操作執行失敗');
		}
	}catch(error){
		console.log(`HTTP請求失敗: ${error}`);
	}
}
httpRequest('https://jsonplaceholder.typicode.com/todos/1');
```

##### 🔸XMLHttpRequest VS. Fetch

^ddf68b

|      | XMLHttpRequest |             Fetch              |
| :--: | :------------: | :----------------------------: |
|  核心  |   基於callback   |           基於Promise            |
|  語法  |       複雜       |               簡潔               |
| 錯誤處理 |      使用事件      | 鏈式.catch( )/ try{ }catch( ){ } |
| 請求終止 |    abort( )    |             原生不支援              |
| 進度監控 |   progress事件   |             原生不支援              |



#### 🟠 AJAX (Asynchronous JavaScript and XML): 一種前端操作模式

^5516fd
---

用於網頁前端與伺服器間溝通的技術: 網頁發送請求 & 伺服器回應
讓網頁能在不重新整理頁面的情況下動態刷新資料(非同步交換資料)

構成要素:
- JavaScript: 發送請求
- XHR (XMLHttpRequest)/ Fetch( ): 與Server端交換資料
- Server端語言(PHP, Node.js等): 處理請求
- 資料格式(XML, JSON等)

運作流程:
	使用者觸發事件
		↓
	JavaScript建立請求(fetch/ XHR)
		↓
	Server端接收處理 並回傳指定格式資料
		↓
	JavaScript解析資料 並更新部分頁面